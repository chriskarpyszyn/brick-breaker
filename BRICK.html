<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <title>BRICK</title>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>

    var canvas;
    var canvasContext;

    var ballX, ballY;
    var ballSpeedX = 0;
    var ballSpeedY = 0;
    var ballSpeedXMultipler = 0.35;

    var paddleWidth = 100;
    var paddleHeight = 10;
    var paddleX, paddleY;

    var ballRadius = 10;

    const BRICK_WIDTH = 80;
    const BRICK_HEIGHT = 20;
    const BRICK_GAP = 2;
    const BRICK_COLS = 10;
    const BRICK_ROWS = 14;

    const INITIAL_BALL_SPEED_X = 5;
    const INITIAL_BALL_SPEED_Y = 5;

    var brickGrid = new Array(BRICK_COLS * BRICK_ROWS);

    var brickCounter = 0;

    var debug = false;

    window.onload = function() {
        const fps = 30;
        canvas = document.getElementById('gameCanvas');
        canvasContext = canvas.getContext('2d');

        //hack for keydown events. probably a better way to do this.
        //http://stackoverflow.com/questions/15631991/how-to-register-onkeydown-event-for-html5-canvas
        canvas.tabIndex = 1000;
        canvas.style.outline = "none";

        resetBall();
        resetBricks();

        paddleX = canvas.width / 2 - paddleWidth / 2;
        paddleY = canvas.height*.9 - paddleHeight;

        canvas.addEventListener('mousemove', function(evt) {
            const mousePos = calculateMousePos(evt);
            paddleX = mousePos.x - (paddleWidth / 2);

            if (debug) {
                ballX = mousePos.x;
                ballY = mousePos.y;
            }
        });

        canvas.addEventListener('keydown', function(evt) {
            var keyCode = evt.keyCode;
            //q
            if (keyCode == 81) {
                if (debug == true) {
                    debug = false;
                } else {
                    debug = true;
                }
            }
        });
        

        setInterval(function() {
            move();
            draw();
        }, 1000 / fps);
    };

    function move() {

        const ballLeft = ballX - ballRadius;
        const ballRight = ballX + ballRadius;
        const ballTop = ballY - ballRadius;
        const ballBottom = ballY + ballRadius;

        ///todo: BUG, ball get's stuck in the side on some collisions
        if (ballLeft < 0) {
            ballSpeedX *= -1;
        }

        if (ballRight > canvas.width) {
            ballSpeedX *= -1;
        }

        if (ballTop < 0) {
            ballSpeedY *= -1;
        }

        if (ballTop >= canvas.height) {
            resetBall();
        }

        //collision with bottom or top of the ball
        if (ballSpeedY > 0) {
            if (ballBottom >= paddleY && ballBottom <= paddleY + paddleHeight
                || ballTop >= paddleY && ballTop <= paddleY + paddleHeight) { //Not sure if this makes sense, but allows for extreme side hits.
                if (ballX >= paddleX && ballX < paddleX + paddleWidth) {
                    const delta = ballX - (paddleX + paddleWidth / 2);
                    ballSpeedX = delta * ballSpeedXMultipler;
                    ballSpeedY *= -1;
                    if (brickCounter === 0) {
                        resetBricks();
                    }
                }
            }
        }

        //collision with left or right of ball
        if (ballSpeedY > 0) {
            if (ballRight >= paddleX && ballRight <= paddleX + paddleWidth
                || ballLeft >= paddleX && ballLeft <= paddleX + paddleWidth) {
                if (ballY >= paddleY && ballY < paddleY + paddleHeight) {
                    const delta = ballX - (paddleX + paddleWidth / 2);
                    ballSpeedX = delta * ballSpeedXMultipler;
                    ballSpeedY *= -1;
                    if (brickCounter === 0) {
                        resetBricks();
                    }
                }
            }
        }
        
        ///todo: need to fix ballX, ballY to detect at outer edge of circle and not center (clipping issues)
        breakAndBounceOffBrickAtPixelCoord(ballX, ballY);


        ballX += ballSpeedX;
        ballY += ballSpeedY;

    }

    function draw() {
        colorRect(0, 0, canvas.width, canvas.height, '#000000');

        colorRect(paddleX, paddleY, paddleWidth, paddleHeight, '#FFFFFF');

        drawBricks();

        colorCircle(ballX, ballY, ballRadius, '#FFFFFF');

        drawDebug();


    }

    function drawBricks() {

        for (var i = 0; i < BRICK_COLS; i++) {
            for (var j = 0; j < BRICK_ROWS; j++) {

                if (isBrickAtTileCoord(i, j)) {
                    colorRect((i * BRICK_WIDTH), (j * BRICK_HEIGHT), BRICK_WIDTH - BRICK_GAP,
                    BRICK_HEIGHT - BRICK_GAP, '#A1DAED');
                }
            }
        }  
    }

    function colorRect(topLeftX, topRightY, boxWidth, boxHeight, fillColor) {
        canvasContext.fillStyle = fillColor;
        canvasContext.fillRect(topLeftX, topRightY, boxWidth, boxHeight);
    }

    function colorCircle(centerX, centerY, radius, fillColor) {
        canvasContext.fillStyle = fillColor;
        canvasContext.beginPath();
        canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
        canvasContext.fill();
    }

    function calculateMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        const root = document.documentElement;

        //account for margins, canvas position on page, scroll amount
        const mouseX = evt.clientX - rect.left - root.scrollLeft;
        const mouseY = evt.clientY - rect.top - root.scrollTop;

        return {
            x: mouseX,
            y: mouseY
        };
    }

    function resetBall() {
        ballX = canvas.width / 2;
        ballY = canvas.height / 2;
        ballSpeedX = INITIAL_BALL_SPEED_X;
        ballSpeedY = INITIAL_BALL_SPEED_Y;
    }

    function resetBricks() {
        for (let i = 0; i < brickGrid.length; i++) {
            //brickGrid[i] = 1;
            if (Math.random() < 0.5) {
                brickGrid[i] = 1;
                brickCounter++;
            } else {
                brickGrid[i] = 0;
            }
        }
    }

    function brickTileToIndex(tileCol, tileRow) {
        return tileCol + tileRow * BRICK_COLS;
    }

    function isBrickAtTileCoord(brickTileCol, brickTileRow) {
        var brickIndex = brickTileToIndex(brickTileCol, brickTileRow);
        return (brickGrid[brickIndex] === 1);
    }


    //function CheckAndRemoveBrickAtPixelCoord(pixelX, pixelY) {

    //    var tileCol = Math.floor(pixelX / BRICK_WIDTH);
    //    var tileRow = Math.floor(pixelY / BRICK_HEIGHT);
    //    if (tileCol < 0 || tileCol >= BRICK_COLS || tileRow < 0 || tileRow >= BRICK_ROWS) {
    //        return false;
    //    }
    //    var brickIndex = brickTileToIndex(tileCol, tileRow);
    //    if (brickGrid[brickIndex] === 1) {
    //        brickGrid[brickIndex] = 0;
    //        return true;
    //    }
    //    return false;
    //}

    function breakAndBounceOffBrickAtPixelCoord(pixelX, pixelY) {
        var tileCol = Math.floor(pixelX / BRICK_WIDTH);
        var tileRow = Math.floor(pixelY / BRICK_HEIGHT);

        if (tileCol < 0 || tileCol >= BRICK_COLS || tileRow < 0 || tileRow >= BRICK_ROWS) {
            return;
        }

        var brickIndex = brickTileToIndex(tileCol, tileRow);

        if (brickGrid[brickIndex] === 1) {
            //why ballX, ballY and not pixelX and pixelY?
            var prevBallX = pixelX - ballSpeedX;
            var prevBallY = pixelY - ballSpeedY;
            var prevTileCol = Math.floor(prevBallX / BRICK_WIDTH);
            var prevTileRow = Math.floor(prevBallY / BRICK_HEIGHT);

            var bothTestFailed = true;

            ///todo: getting weird bounces where both tileCol!=prevtilecol and tileRow!=prevtilerow
            var adjacentBrickIndex;
            if (tileCol !== prevTileCol) {
                adjacentBrickIndex = brickTileToIndex(prevTileCol, tileRow);
                if (brickIndex[adjacentBrickIndex] !== 1) {
                    ballSpeedX *= -1;
                    bothTestFailed = false;
                }
            }
            if (tileRow !== prevTileRow) {
                adjacentBrickIndex = brickTileToIndex(tileCol, prevTileRow);
                if (brickIndex[adjacentBrickIndex] !== 1) {
                    ballSpeedY *= -1;
                    bothTestFailed = false;
                }
            }

            if (bothTestFailed) {
                ballSpeedX *= -1;
                ballSpeedY *= -1;
            }

            brickGrid[brickIndex] = 0;
            brickCounter--;
        }
    }

    function drawDebug() {
        if (debug) {

            var ballSize = 2.5;

            colorCircle(ballX, ballY - ballRadius, ballSize, 'red');
            colorCircle(ballX, ballY + ballRadius, ballSize, 'green');
            colorCircle(ballX - ballRadius, ballY, ballSize, 'blue');
            colorCircle(ballX + ballRadius, ballY, ballSize, 'cyan');

            colorCircle(paddleX, paddleY, ballSize, 'red');
            colorCircle(paddleX, paddleY + paddleHeight, ballSize, 'pink');
            colorCircle(paddleX + paddleWidth, paddleY, ballSize, 'blue');
            colorCircle(paddleX + paddleWidth, paddleY + paddleHeight, ballSize, 'cyan');

        }
    }



</script>

</body>
</html>